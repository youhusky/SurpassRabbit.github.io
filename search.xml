<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redux"使用"教程]]></title>
    <url>%2F2018%2F08%2F07%2Fredux%E2%80%9D%E4%BD%BF%E7%94%A8%E2%80%9C%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[如果在学习react-native的过程中遇到什么问题，欢迎加入QQ群397885169一起学习，一起成长。 识兔，一款用来识别图片的开源项目，在未来还会添加更多有意思的东西 识兔现已重构，完全按照上线项目作为开发标准，使用Mobx管理状态，适配iPhoneX和安卓各种异形屏，还有更多有意思的东西等待您的发现 您的star就是对我最大的帮助 本文的Demo最终的运行效果 前言本文仅写给在项目中没用使用过redux，又急于利用redux开发的同学们。 之前开源rn版百思不得姐的时候，写过几篇文章，有人问什么时候会出rn+redux的文章，我也犹豫了很久，因为在开源百思的时候，没有用到跨页面传递状态。 上个月我开源了识兔(可以识别手机中或者拍摄的图片)，本来打算使用mobx来做状态管理的，但在真正使用过程中，可能是我的方法不对，我总感觉mobx总有那么一点欠缺，深思熟虑之后，还是决定使用redux来管理项目中的状态。 在之前学习redux的过程中发现，网上和Github上确实有很多开源redux的例子，和介绍redux的文章，但很少有从新手角度考虑的文章，绝大部分新手不一定需要知道redux是干什么的，他们只是想尽快的在项目中使用它，而我也认为不用你咋知道原理是啥，所以我写了这篇文章，用识兔项目中的几个小案例来让新同学入了redux的门。 ps:哪怕真的不愿意知道redux的原理，也需要知道redux中基本概念和 API，比如说在项目中会经常用到的Store、Action、Reducer等等。而为了知道怎么用，最简单的方式就是去看其他开源的项目，但看的越多只会让你的思路越凌乱，所以在文章中用我的写法，每个人理解的redux都不一样，但万变不离其宗，学会一种之后可以再根据自己的需求更改。 需求1.网络请求：redux最简单的需求当然就是网络请求了，识兔首页，进入App的时候是需要请求一次网络的，用来验证UserToken，如果不存在就从网络获取并保存，如果存在就直接取出来。2.跨页面修改状态：识兔的首页背景图是个大美女，我要在福利(瀑布流)页面的图片详情中，可以修改首页的背景图，之前的写法是通过通知的方式，但redux本身就是可以跨页面传值的。 实现逆向工程 为什么要提到逆向工程呢？因为本文的写法可能会与正常的数据redux逻辑不太一样，它会反着写，会让你很快看到效果，而不是要全部把Action、Reducer全都写完了，才能看到完整的效果。 用到的redux库1234redux,react-redux,redux-logger,redux-thunk 1. 包装入口文件#####入口文件：因为在rn中，iOS和安卓平台入口是两个文件index.ios.js和index.android.js，为了跨平台，一般都会创建统一的入口文件。识兔项目的入口文件是app目录下的index.js文件。 index.js 12345678910111213141516171819202122232425import &#123; AppRegistry,View,Text &#125; from &apos;react-native&apos;;import React, &#123; Component &#125; from &apos;react&apos;;// 引入react-reduximport &#123;Provider&#125;from &apos;react-redux&apos;;// 引入store文件，下步会创建import configureStore from &apos;./store/ConfigureStore&apos;;// 调用 store 文件中的rootReducer常量中保存的方法const store = configureStore();// 项目中使用了react-navigation，推荐的做法是将初始文件写在一个文件中，// 所以App.js也可以看做是页面的初始化入口import App from &apos;./APP&apos;;export default class Root extends Component &#123; render() &#123; return ( // 包装App &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; ); &#125;&#125; 2. 创建ConfigureStore文件store：在上一步的时候，会发现有一个ConfigureStore,这个就是我们俗称的store。ConfigureStore.js 123456789101112131415161718192021222324// redux库里面提供的方法，创建store和middleware中间件import &#123;createStore,applyMiddleware&#125; from &apos;redux&apos;;// redux-thunk是用来发送异步请求的中间件，用了thunk之后，// 一般的操作是将网络请求的方法放在action中，后面会有说明import thunk from &apos;redux-thunk&apos;;// redux-logger打印logger的中间件，具体效果可以看下图import logger from &apos;redux-logger&apos;;// rootReducer下一步会创建import RootReducer from &apos;../reducers/RootReducer&apos;;let middlewares = [];middlewares.push(logger);middlewares.push(thunk);// 通过applyMiddleware将中间件添加const createStoreWithMiddleware = applyMiddleware(...middlewares)(createStore);// 导出configureStore，里面携带着reducer，中间件，初始值export default function configureStore(initialState)&#123; return createStoreWithMiddleware(RootReducer,initialState);&#125; 3. 创建RootReducer文件reducer：RootReducer中放的是各个页面的Reducer，推荐的做法是一个页面公用一个Reducer，便于之后管理。RootReducer.js 1234567891011// Reducer是纯函数，里面不应该有过多的逻辑。import &#123; combineReducers &#125; from &apos;redux&apos;;// 这个是ShiTu页面中用到的Reducerimport ShiTuReducer from &apos;./ShiTuReducer&apos;;// 下面这个还未实现// import GankReducer from &apos;./GankReducer&apos;;// 取决于这里你加入了多少 reducerconst RootReducer = combineReducers(&#123; ShiTuReducer,&#125;);export default RootReducer; ShiTuReducer.js 12345678910111213141516171819202122232425262728293031323334353637383940414243// ActionTypes里面存放着App中可能发生的情况import * as types from &apos;../constant/ActionTypes&apos;;// 初始化值const initialState = &#123; imageURL: &apos;timg&apos;, userToken: &apos;&apos;, webViewUrl: &apos;&apos;, qiNiuData: null,&#125;;// 导出ShiTuReducer。export default function ShiTuReducer(state = initialState, action)&#123; // console.log(action); // 通过switch来判断types的值，在action中实现功能 switch (action.type) &#123; // 当type=USER_TOKEN_SUCCESS时，会将action中的值， // 赋给userToken，在ShiTu.js中就能拿到userToken的值。 case types.USER_TOKEN_SUCCESS: // console.log(action); return Object.assign(&#123;&#125;, state, &#123; ...state, userToken: action.userToken, &#125;); case types.QINIU_UPLOAD_TOKEN: // console.log(action); return Object.assign(&#123;&#125;, state, &#123; qiNiuData:action.qiNiuData, &#125;); case types.WEBVIEW_URL: return Object.assign(&#123;&#125;, state ,&#123; ...state, webViewUrl:action.webViewUrl, &#125;); case types.BACKIMAGE_URL: return Object.assign(&#123;&#125;, state ,&#123; imageURL:action.imageURL, &#125;); default: return state; &#125;&#125; 4. 创建ActionTypes文件actionTypes：在使用redux过程中，需要给每个动作添加一个actionTypes类型，比如说在上面，我要获取userToken，就需要再actionTypes中加上USER_TOKEN，而有些时候，调用网络会有成功/失败两种状态，所以可以将这个状态更加细分USER_TOKEN_SUCCESS/USER_TOKEN_ERRO。ActionTypes.js 123456// 用户Tokenexport const USER_TOKEN_SUCCESS = &apos;USER_TOKEN_SUCCESS&apos;;// 获取失败export const USER_TOKEN_ERROR = &apos;USER_TOKEN_ERROR&apos;;// 首页背景图片export const BACKIMAGE_URL = &apos;BACKIMAGE_URL&apos;; 5. 创建xxxAction文件xxxAction：可能在一个页面需要用到多个action，比如说我识兔页面中，进入app的时候需要调用获取userToken的action，点击查找按钮的时候需要调用获取图片信息的action。每个页面是可以有多个action的，只需要在页面中引入就好ShiTuUserToken.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 获取actionType中的全部状态，需要哪个就用哪个import * as types from &apos;../constant/ActionTypes&apos;;// 网络请求的网址和网络请求的方法import Config from &apos;../common/Config&apos;;import Request from &apos;../common/Request&apos;;import &#123; AsyncStorage &#125; from &apos;react-native&apos;;// 存储信息的KEYlet KEY = &apos;USERTOKEN&apos;;// 这个方法是请求网络，获取Token的方法// 识兔中调用这个方法之后，需要判断是否存在userToken，不存在请求网络并保存，存在直接调用返回export function userToken() &#123; return dispatch =&gt; &#123; return Request.get(Config.api.getUserToken,(data)=&gt;&#123; AsyncStorage.getItem(KEY,(Error,result)=&gt;&#123; if (result === null)&#123; Request.get(Config.api.getUserToken,(data)=&gt;&#123; // console.log(data); if (data &amp;&amp; data.success)&#123; let token = data.token; AsyncStorage.setItem(KEY,token,(error)=&gt;&#123; if (error)&#123; console.log(&apos;存储失败&apos; + error); &#125;else &#123; console.log(&apos;存储成功&apos;); // dispatch发送数据到Reducer里面 dispatch(getUserToken(token)); &#125; &#125;) &#125; &#125;,(error)=&gt;&#123; console.log(error); &#125;) &#125;else &#123; console.log(&apos;获取成功&apos; + result); dispatch(getUserToken(result)); &#125; &#125;); &#125;,(error)=&gt;&#123; console.log(error); dispatch(&#123;type: types.USER_TOKEN_ERROR, error: error&#125;); &#125;); &#125;&#125;;// 如果()括号里面的参数`userToken`和Reducer里面的初始参数一样，就可以不用键：值的写法，直接返回就好。export function getUserToken(userToken) &#123; return &#123; // type是必要参数，通过type值判断 type: types.USER_TOKEN_SUCCESS, userToken &#125;&#125; 6. connect连接页面和Reducer，完成需求1connect：如果完成了上面的步骤，恭喜你，还差最后一步就可以看到运行的效果了，那就是在需要的页面connect。因为ShiTu.js中代码过多，所以只在文章中放重要的部分，如果想要查看全部，可以运行项目或者直接查看ShiTu.jsShiTu.js 123456789101112131415161718192021222324252627282930313233// 引入需要用到的方法···// 引入connect和bindActionCreatorsimport &#123; connect &#125; from &apos;react-redux&apos;;import &#123; bindActionCreators &#125; from &apos;redux&apos;;// 引入获得userToken的action方法import &#123; userToken &#125; from &apos;../../actions/ShiTuUserToken&apos;;···// 导出ShiTu页面并连接Reducer···// connect 连接 Recucer ，我ShiTu.js的Reducer叫ShiTuReducer，// userToken等方法是我在action里面创建的，所以调用的也就是action方法export default connect((state) =&gt; &#123; const &#123; ShiTuReducer &#125; = state; return &#123; ShiTuReducer &#125;;&#125;,&#123; userToken &#125;)(ShiTu)···// 使用componentDidMount()&#123; console.log(&apos;componentDidMount&apos;); // 使用userToken方法。 this.props.userToken(); &#125; render() &#123; console.log(&apos;render&apos;); // 掉用过上面的方法后就可以通过打印`ShiTuReducer`获得需要的数据 console.log(this.props.ShiTuReducer);&#125; 完成上面的6步，就可以在现有的项目中使用redux开发了。在第6步中我们只是完成了需求1，接下来就要利用redux实现跨页面更改状态了。1. 寻找需求并不是每个App都需要用到跨页面更改状态的，但在识兔中，我心中的想法是，识兔项目中多数的页面布局都可以由用户自定义，所以我选择了redux，如果不需要用到跨页面更改状态，使用state管理也是没有问题的。需求2的操作流程是，在福利的图片详情页WelfarePicture.js中长按图片弹出actionSheet，点击设为主屏幕就可以修改首页的背景图片了。 2. 实现实现逻辑和获取userToken基本一样，唯一的区别就是，点击按钮的时候，需要通过dispatch传递图片的url地址到Reducer中。 WelfarePicture 1234567891011121314151617181920212223242526272829303132333435// 因为···import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; bindActionCreators &#125; from &apos;redux&apos;;import &#123; backImage,getBackImage &#125; from &apos;../../actions/ShiTuBackImage&apos;;······export default connect((state) =&gt; &#123; const &#123; ShiTuReducer &#125; = state; return &#123; ShiTuReducer &#125;;&#125;,&#123; backImage,getBackImage&#125;)(WelfarePicture)···// 下面的方法就是点击actionSheet的方法···handlePress(url,i) &#123; let SHITUIMAGEKEY = &apos;SHITUIMAGEKEY&apos;; if(i===2)&#123; AsyncStorage.setItem(SHITUIMAGEKEY,url,(error)=&gt;&#123; if (error)&#123; console.log(&apos;存储失败&apos; + error); &#125;else &#123; console.log(&apos;存储成功&apos;); // 通过getBackImage方法将图片的url发给Reducer，Reducer中就会相应的更新页面 this.props.getBackImage(url); &#125; &#125;) &#125; &#125;··· 总结在文章中真的没有多说redux原理，如果有想了解的同学可以参考阮一峰老师的几篇文章，讲的清晰透彻。 本文只是我对于实现redux的一点看法，可能并不适用于你的项目，如果在使用过程中遇到什么问题，欢迎加QQ群397885169讨论。如果认为我的文章不错，欢迎打赏，关注，喜欢。如果感觉我的文章有问题，欢迎在评论区提出，我会修改。]]></content>
  </entry>
  <entry>
    <title><![CDATA[react-native实现上传功能]]></title>
    <url>%2F2018%2F08%2F07%2Freact-native%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[如果在学习react-native的过程中遇到什么问题，欢迎加入QQ群397885169一起学习，一起成长。 识兔，一款用来识别图片的开源项目，在未来还会添加更多有意思的东西 识兔现已重构，完全按照上线项目作为开发标准，使用Mobx管理状态，适配iPhoneX和安卓各种异形屏，还有更多有意思的东西等待您的发现 您的star就是对我最大的帮助 前言在我最新开源的识兔项目中，最重要的功能就是识别图片了，而图片的识别过程如下 选中/拍摄 =&gt; 上传图片 =&gt; 后台返回识别之后的url 第一步中可能遇到的坑，在我另一篇文章有过讲解react-native-image-picker在iOS上闪退的解决办法，如果还有其他的问题，欢迎在评论区提出。第二步就是上传图片了，在本文中会给出两种上传图片的方式。原生上传图片和使用rn-fetch-blob实现上传图片。第三步，需要涉及一些后台的东西和web加载的动画，我的规划是先将web的加载动画写出来，后续将nodejs后台的搭建和使用，再写点东西。注：本文中是将图片上传到七牛云。上传到其他空间，代码也是大同小异。注：react-native-fetch-blob的原作者很久不更新了，现在这个库的名字叫做rn-fetch-blob 准备工作不管是原生上传还是使用第三方上传，有个步骤都是不能省略的，那就是需要知道上传到哪，哪怕在写过要上传到七牛，但七牛那么大，具体到哪个存储空间这都是需要知道的。 在上传之前除了要知道上传的存储空间之外，还要获得七牛返回的参数，通过七牛返回的hash来真正的完成上传，但这个获取hash的过程不推荐在前端做处理，最好是放在后端（但如果非要放在前端也是没问题的，代码都是差不多的）。 下面的代码，是我开源识兔的本地服务器代码，如果遇到不明白的问题，可以在github上查看，或者加397885169一起讨论 12345678910111213141516171819// 引入七牛，var qiniu = require(&apos;qiniu&apos;);// 引入uuid，用它构建唯一的keyvar uuid = require(&apos;uuid&apos;);var putPolicy;// 唯一的keyvar key = uuid.v4();// 处理格式key += &apos;.jpeg&apos;;// 通过七牛提供的方法，构建上传策略函数，imagePutPolicy就是上传的空间名putPolicy = new qiniu.rs.PutPolicy(config.qiniu.imagePutPolicy + &quot;:&quot; + key); var token = putPolicy.token()// 返回key和tokenreturn &#123; key : key, token:token,&#125;; 使用原生方式上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 创建form表单let body = new FormData();// token和key都是通过七牛返回的参数body.append(&apos;token&apos;,token);body.append(&apos;key&apos;,key);body.append(&apos;file&apos;,&#123; // 设定上传的格式 type : &apos;image/jpeg&apos;, // 通过react-native-image-picker获取的图片地址 uri : uri, name : key, &#125;);// 开启XMLHttpRequest服务const xhr = new XMLHttpRequest();/** 上传到七牛云的地址 */const url = Config.qiniu.upload;// 开启post上传xhr.open(&apos;POST&apos;,url);// 如果正在上传,返回上传进度if (xhr.upload)&#123; xhr.upload.onprogress = (event)=&gt;&#123; if (event.lengthComputable)&#123; let perent = event.loaded / event.total.toFixed(2); // 打印上传进度 console.log(perent); &#125; &#125;&#125; // 上传过成功的返回xhr.onload = () =&gt; &#123; // console.log(xhr.status); // 状态码如果不等于200就代表错误 if (xhr.status !== 200)&#123; alert(&apos;请求失败&apos;); console.log(xhr.responseText); return; &#125; if (!xhr.responseText)&#123; alert(&apos;请求失败&apos;); console.log(xhr.responseText); return; &#125; // 服务器最后返回的数据 let response; try&#123; // 将返回数据还原 response = JSON.parse(xhr.response); console.log(response); // ...通过返回数据做接下来的处理 &#125; &#125;// 发送请求xhr.send(body); 使用rn-fetch-blob上传12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; const token = data.data.token; const key = data.data.key; // 这里需要将&apos;///&apos;处理掉,因为使用wrap的时候,会再包裹一层 // 本文的fetch-blob使用的是0.10.4版本，据说其他版本不用添加下面的代码。 const PATH = iOS ? response.uri.replace(&apos;file:///&apos;,&apos;&apos;) : response.uri; // 创建上传的请求头，使用fetch-blob必须要遵循name，data的格式，要不然就不成功。 const body = [&#123; name: &apos;token&apos;, data: token, &#125;, &#123; name: &apos;key&apos;, data: key, &#125;,&#123; name: &apos;file&apos;, filename: key || &apos;file&apos;, data: RNFetchBlob.wrap(PATH) &#125;]; RNFetchBlob .fetch(&apos;POST&apos;, url, &#123; // 上传图片要设置Header &apos;Content-Type&apos;: &apos;multipart/form-data&apos;, &#125;,body) .uploadProgress((written, total) =&gt; &#123; // 本地查找进度 &#125;) .progress((received, total) =&gt; &#123; let perent = received / total; // 上传进度打印 console.log(perent); &#125;) .then((response) =&gt; response.json()) .then((response) =&gt; &#123; // 上传信息返回 console.log(response); &#125;) .catch((error) =&gt; &#123; // 错误信息 console.log(error); &#125;);&#125; 比较 原生的上传方式对于开发过原生JavaScript的人来说，其实更好理解，但对于没有写过原生js的童鞋，就需要去了解XMLHttpRequest和它的一些api才能完成上传的操作。 rn-fetch-blob封装了上传的功能，对于开发者来说，api更简单，也更便于操作。唯一的缺点就是body必须按照官方提供的格式填写，有一点不同都会报错，作者之前就卡在这上面好长时间。 经过测试，4M以下的图片好像是获取不到上传进度的，如果有更好的解决办法，欢迎提出。 总结 本文是作者在上传图片过程中，对于两种方式的总结，可能会有写的不清楚或者不正确的地方，欢迎在评论区评论，或者加397885169一起讨论。作者以后会书写更多有关react-native的文章。]]></content>
  </entry>
  <entry>
    <title><![CDATA[react-native组件的拆分技巧]]></title>
    <url>%2F2018%2F08%2F07%2Freact-native%E7%BB%84%E4%BB%B6%E7%9A%84%E6%8B%86%E5%88%86%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[如果在学习react-native的过程中遇到什么问题，欢迎加入QQ群397885169一起学习，一起成长。 识兔，一款用来识别图片的开源项目，在未来还会添加更多有意思的东西 识兔现已重构，完全按照上线项目作为开发标准，使用Mobx管理状态，适配iPhoneX和安卓各种异形屏，还有更多有意思的东西等待您的发现 您的star就是对我最大的帮助 前言React组件具有很强的灵活性和功能性。 在JS.COACH上有很多组件库可供使用，但随着时间的增长组件会变得非常臃肿。 与任何其他类型的编程一样，遵守单一原则不仅使您的组件更易于维护，而且还可以实现更多的复用。 但是，确定如何分离大型React组件的职责并不是很容易的。 这里有三种技巧让你从简单到复杂的方式学会拆分组件。 拆分render()这是使用最多的，也是最简单的方式：当组件呈现太多元素时，将这些元素拆分为逻辑子组件。 拆分render() 是一个常见且快速的方式，是在同一个class中创建其他“子组件”方式： 123456789101112131415161718class Test extends React.Component &#123; renderItem() &#123; // ... &#125; renderHeader() &#123; // ... &#125; render() &#123; return ( &lt;View&gt; &#123;this.renderItem()&#125; &#123;this.renderHeader()&#125; &lt;/View&gt; ); &#125;&#125; 虽然上面的方法也可以，但它不是真正的分解组件。页面中的state, props, 和类方法仍然是共享的，因为还是很难确定哪个“子组件”使用哪些方法。 无状态组件要真正降低复杂度，应该创建全新的组件。对于更简单的子组件，功能组件可以使用以下的方式创建，也就是无状态组件，用来保证低耦合： 1234567891011121314151617181920const TestItem = (props) =&gt; ( return () &#123; &lt;Text title=&#123;props.title&#125;/&gt; &#125;);const TestHeader = (props) =&gt; ( // ...);class Test extends React.Component &#123; render() &#123; return ( &lt;View&gt; &lt;TestItem title=&#123;this.props.title&#125;/&gt; &lt;TestHeader title=&#123;this.props.title&#125;/&gt; &lt;/View&gt; ); &#125;&#125; 通过这种方式拆分，有一个重要的差异。使用无状态组件替代直接的函数调用，可以为React生成较小的单元。通过使用浅渲染来轻松隔离这些单元进行独立测试。而对于性能来说，这样做会更好，因为较小的单元将更有效的执行渲染。 创建独立的React组件如果组件由于多种属性或者变化而变得复杂，可以考虑将组件拆分成具有一个多个公开属性的模板组件。这样可以让父组件更专注于数据传递，将逻辑层放在子组件中，单独的组件维护各自的生命周期。 例如：在开发过程中，某些子组件可能会有不同的操作或者加载不同的数据，利用React中的props来传递参数，通过参数来控制子组件的样式。 12345678910111213141516class TestItem extends React.Component &#123; static propTypes = &#123; title: PropTypes.string, press: PropTypes.func, &#125;; render() &#123; const &#123; title, press &#125; = this.props; return ( &lt;View&gt; &lt;Text&gt;&#123;title&#125;&lt;/Text&gt; &lt;Button onPress=&#123;press&#125; title=&apos;点击我&apos; /&gt; &lt;/View&gt; ); &#125;&#125; 当然也可以继续拆分class组件，只负责单独的功能，类似上面的无状态组件功能性组件推荐继承React.PureComponent，详细介绍可以参考👇 123456class Test extends React.PureComponent &#123; render() &#123; return &lt;TestItem title=&#123;&apos;我是标题&apos;&#125; press=&#123;()=&gt;&#123;alert(&apos;我是点击事件&apos;)&#125; /&gt;; &#125;&#125; 在JSX中，组件的开始和结束标签之间的任何东西都可以作为特殊的子组件传递。当正确使用时，都可以表现出来。 使用PureComponent 当组件的props或者state发生变化的时候：React会对组件当前的Props和State分别与nextProps和nextState进行比较，当发现变化时，就会对当前组件以及子组件进行重新渲染，否则就不渲染。有时候为了避免组件进行不必要的重新渲染，我们通过定义shouldComponentUpdate来优化性能。 与Component相比较，PureComponent会自动帮助我们处理shouldComponentUpdate。 大多数情况下， 我们使用PureComponent能够简化我们的代码，并且提高性能，但是PureComponent的自动为我们添加的shouldComponentUpate函数，只是对props和state进行浅比较(shadow comparison)，当props或者state本身是嵌套对象或数组等时，浅比较并不能得到预期的结果，这会导致实际的props和state发生了变化，但组件却没有更新的问题。 123456789101112131415161718192021222324252627282930class ListOfWords extends React.PureComponent &#123; render() &#123; return &lt;Text&gt;&#123;this.props.words.join(&apos;,&apos;)&#125;&lt;/Text&gt;; &#125; &#125;class WordAdder extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; words: [&apos;marklar&apos;] &#125;; &#125; handleClick = () =&gt; &#123; this.setState(prevState =&gt; (&#123; words: prevState.words.concat([&apos;marklar&apos;]) &#125;)); &#125; render() &#123; return ( &lt;View&gt; &lt;Button onPress=&#123;this.handleClick&#125; /&gt; &lt;ListOfWords words=&#123;this.state.words&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 高阶组件高阶组件展示了React的强大的组合性质。通常用于React库，例如react-redux，styled-components和react-intl。 毕这些库都是解决任何React应用程序的通用方面。 结语React的设计模式是高度可组合组件化。 通过分解和组合它们，可以解决很多问题。不要因为麻烦去讨厌创建子组件，起初可能会感觉麻烦，但最终会发现程序的性能和组件的可复用性都会很大的提升。 在开发中，如果组件内部拥有state，或者需要使用生命周期函数的组件，更推荐使用PureComponent，因为它提供了更好的性能，同时强制你使用不可变的对象，保持良好的编程习惯。 如果不需要生命周期，不需要state，请尽可能多的使用无状态组件吧！]]></content>
  </entry>
  <entry>
    <title><![CDATA[react-navigation 2.x使用技巧]]></title>
    <url>%2F2018%2F08%2F05%2Freact-navigation%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[本文是基于最新的react-navigation^2.5.3来书写的。 如果在学习react-native的过程中遇到什么问题，欢迎加入QQ群397885169一起学习，一起成长。 识兔，一款用来识别图片的开源项目，在未来还会添加更多有意思的东西 识兔现已重构，完全按照上线项目作为开发标准，使用Mobx管理状态，适配iPhoneX和安卓各种异形屏，还有更多有意思的东西等待您的发现 您的star就是对我最大的帮助 react-navigation使用技巧(进阶篇) 什么是react-navigation?react-native从开源至今，一直存在几个无法解决的毛病，偶尔就会复发让人隐隐作痛，提醒你用的不是原生，其中包括列表的复用问题，导航跳转不流畅的问题等等。终于facebook坐不住了，在前一段时间开始推荐使用react-navigation，并且在0.44发布的时将之前一直存在的Navigator废弃了。react-navigation是致力于解决导航卡顿，数据传递，Tabbar和navigator布局，支持redux。虽然现在功能还不完善，但基本是可以在项目中推荐使用的。 属性react-navigation分为三个部分。 StackNavigator类似顶部导航条，用来跳转页面和传递参数。 TabNavigator类似底部标签栏，用来区分模块。 DrawerNavigator抽屉，类似从App左侧滑出一个页面，在这里不做讲解。 下面会分开讲解官网提供的配置方法，但顺序可能会官网不一样。 距离我上一个版本的react-navigation教程已经有1年多的时间了，虽然一直在缝缝补补，但那个教程真的老了。正好react-navigation V2版本也即将要正式发布了，趁着这次机会重新梳理一下教程，并把之前的坑和遗憾填补一下。 我会将本文分成三部分，第一部分是介绍使用技巧，第二部分是常用API，第三部分是属性方法。 使用技巧跳转1234navigate(&apos;Detail&apos;,&#123; title:&apos;图片详情&apos;, url:item.url, &#125;); Detail：在StackNavigator中注册的页面，需要一一对应，才能跳转到相应的页面title：在跳转的页面可以通过this.props.navigation.state.params.title获取到这个参数。当然这个参数可以随便填写，都可以通过this.props.navigation.state.params.xxx获取。 最新版本中可以通过push来跳转页面 1this.props.navigation.push(&apos;Detail&apos;); 回调传参123456navigate(&apos;Detail&apos;,&#123; // 跳转的时候携带一个参数去下个页面 callback: (data)=&gt;&#123; console.log(data); // 打印值为：&apos;回调参数&apos; &#125; &#125;); 1234const &#123;navigate,goBack,state&#125; = this.props.navigation;// 在第二个页面,在goBack之前,将上个页面的方法取到,并回传参数,这样回传的参数会重走render方法state.params.callback(&apos;回调参数&apos;);goBack(); 自定义导航条项目中基本是没可能用自带的那个导航条的，自带导航条左侧的按钮永远是蓝色的，如果我们需要更改按钮颜色，就需要用到自定义的功能了。 1234567891011121314151617181920212223const StackOptions = (&#123;navigation&#125;) =&gt; &#123; console.log(navigation); let &#123;state,goBack&#125; = navigation; // 用来判断是否隐藏或显示header const visible= state.params.isVisible; let header; if (visible === true)&#123; header = null; &#125; const headerStyle = &#123;backgroundColor:&apos;#4ECBFC&apos;&#125;; const headerTitle = state.params.title; const headerTitleStyle = &#123;fontSize:FONT_SIZE(20),color:&apos;white&apos;,fontWeight:&apos;500&apos;&#125; const headerBackTitle = false; const headerLeft = ( &lt;Text onPress=&#123;()=&gt;&#123;goBack()&#125;&#125; &gt; 返回 &lt;/Text&gt; ); return &#123;headerStyle,headerTitle,headerTitleStyle,headerBackTitle,headerLeft,header&#125;&#125;; 然后通过下面的方法调用就可以自定制导航了。 123456789const MyApp = StackNavigator(&#123; MyTab: &#123; screen: MyTab, &#125;, Detail: &#123; screen: Detail, navigationOptions: (&#123;navigation&#125;) =&gt; StackOptions(&#123;navigation&#125;) &#125;,)&#125;; 在页面中使用的时候，在跳转页面的时候需要传递title参数，才能看到效果哦。 自定义tabbar早上有人问我，tabbar的图标可不可以使用原图，选中状态下可不可以设置其他图标。研究了一下官方文档，发现tabBarIcon除了tintColor还有另一个属性，用来判断选中状态的focused。 12345678910111213tabBarIcon: (&#123;tintColor,focused&#125;) =&gt; ( focused ? &lt;Image source=&#123;&#123;uri : &apos;识兔&apos;&#125;&#125; style=&#123;tabBarIcon&#125; /&gt; : &lt;Image source=&#123;&#123;uri : &apos;干货&apos;&#125;&#125; style=&#123;[tabBarIcon, &#123;tintColor: tintColor&#125;]&#125; /&gt; ), 通过判断focused，选中状态下使用识兔图标，未选中状态使用干货图标。如果想使用图标原来的样子，那就将style的tintColor去掉，这样就会显示图标原本的颜色。 再封装12345678910111213141516171819202122232425export const TabOptions = (tabBarTitle,normalImage,selectedImage,navTitle) =&gt; &#123; // console.log(navigation); const tabBarLabel = tabBarTitle; console.log(navTitle); const tabBarIcon = ((&#123;tintColor,focused&#125;)=&gt; &#123; return( focused ? &lt;Image source=&#123;&#123;uri : normalImage&#125;&#125; style=&#123;[TabBarIcon, &#123;tintColor: tintColor&#125;]&#125; /&gt; : &lt;Image source=&#123;&#123;uri : selectedImage&#125;&#125; style=&#123;[TabBarIcon, &#123;tintColor: tintColor&#125;]&#125; /&gt; ) &#125;); const headerTitle = navTitle; const headerTitleStyle = &#123;fontSize:FONT_SIZE(20),color:&apos;white&apos;&#125;; // header的style const headerStyle = &#123;backgroundColor:&apos;#4ECBFC&apos;&#125;; return &#123;tabBarLabel,tabBarIcon,headerTitle,headerTitleStyle,headerStyle&#125;;&#125;; 在static中使用this方法我之前文章中是将navaigationOptions的方法写在了app.js中，没有在页面中通过static navaigationOptions来初始化页面，这段时间刚好有人问，所以在这里就写一下该怎么弄。 首先需要在componentDidMount(){}中动态的添加点击事件12345678属性给paramscomponentDidMount()&#123; this.props.navigation.setParams(&#123; title:&apos;自定义Header&apos;, navigatePress:this.navigatePress &#125;)&#125; 1234navigatePress = () =&gt; &#123; alert(&apos;点击headerRight&apos;); console.log(this.props.navigation);&#125; 接下来就可以通过params方法来获取点击事件了12345678static navigationOptions = (&#123; navigation, screenProps &#125;) =&gt; (&#123; title: navigation.state.params?navigation.state.params.title:null, headerRight:( &lt;Text onPress=&#123;navigation.state.params?navigation.state.params.navigatePress:null&#125;&gt; 返回 &lt;/Text&gt; )&#125;); 让安卓实现push动画，并可以滑动返回之前群里的讨论怎么让安卓实现类似iOS的push动画，研究了2.x版本的实现后，真的实现了，在这里共享下 1234567891011121314151617// 在2.x版本中，需要引入下面的方法import StackViewStyleInterpolator from &apos;react-navigation/src/views/StackView/StackViewStyleInterpolator&apos;;// 在StackNavigator配置headerMode的地方，使用transitionConfig添加&#123; // 这个写法是默认去掉自带的导航栏，并且让滑动返回动画生效，如果不想去掉自带的导航，删掉header: null就可以了 navigationOptions: () =&gt; (&#123; header: null, gesturesEnabled: true, &#125;), headerMode: &apos;screen&apos;, // react-navigation中一共实现了四种动画，有需要的可以去进阶篇中查看。 transitionConfig:() =&gt; (&#123; screenInterpolator: StackViewStyleInterpolator.forHorizontal, &#125;)&#125; 安卓上，使用TextInput的时候会让TabBar顶起来的解决办法最简单的解决办法就是在android目录中，添加一句话 目录：android/app/src/main/AndroidManifest.xml中，添加 1android:windowSoftInputMode=&quot;stateAlwaysHidden|adjustPan|adjustResize&quot; ps：在iOS下如果想一劳永逸的解决键盘问题，请使用IQKeyBoardManager。 APIcreateSwitchNavigator SwitchNavigator的目的是一次只显示一个屏幕。默认情况下，它不处理回退操作，并在您切换时将路由重置为默认状态。这是我们从登录流程（包含注册，登录，忘记密码等）到主屏幕的必要流程。这个方法在1.x中叫做SwitchNavigator，在2.x中统一命名为createSwitchNavigator 1createSwitchNavigator(RouteConfigs, SwitchNavigatorConfig); RouteConfigs 路由的配置表，详细配置可以参考下面的createStackNavigator SwitchNavigatorConfig SwitchNavigator属性 initialRouteName - 第一次加载时初始选项卡路由的routeName。 resetOnBlur - 切换离开屏幕时，重置所有嵌套导航器的状态。默认为true。 paths - 提供routeName到path的深度链接，它会覆盖RouteConfigs中设置的路径。 backBehavior - 后退按钮是否会导致标签切换到初始路由？如果是，则设置为initialRoute，否则none。默认为none。 12345678910export default createSwitchNavigator( &#123; AuthLoading: AuthLoadingScreen, App: AppStack, Auth: AuthStack, &#125;, &#123; initialRouteName: &apos;AuthLoading&apos;, &#125;); createStackNavigator 配置路由属性和参数这个方法在1.x中叫做StackNavigator，在2.x中统一命名为createStackNavigator 1createStackNavigator(RouteConfigs, StackNavigatorConfig); RouteConfigs screen - 对应界面名称，是一个React组件 path - 深度链接路径，从其他App或者web跳转到该App需要设置该路径 navigationOptions - 用于屏幕的默认导航选项 StackNavigatorConfig可选的路由属性 initialRouteName - 设置默认屏幕。必须为路由配置中的某个screen。 initialRouteParams - 初始路由路线的参数。 navigationOptions - 用于屏幕的默认导航选项。 paths - 覆盖路由配置中设置的路径的映射。 可选的视觉选项 mode - 定义渲染和转换的样式 card - 使用标准的iOS和Android屏幕转换。这是默认属性。 modal - 使屏幕从底部滑入，这是一种常见的iOS模式。只适用于iOS，对Android没有影响。 headerMode - 定义如何呈现标题 float - 在屏幕更改时渲染保留在顶部的单个标题和动画。这是iOS上的常见效果。 screen - 每个屏幕都附有一个标题，标题与屏幕一起淡入和淡出。这是Android上的常见效果。 none - 不会显示标题。 headerTransitionPreset - 指定标题在headerMode: float启用时应该如何从一个屏幕切换到另一个屏幕。 fade-in-place - 标题组件在不移动的情况下淡入淡出，类似于iOS的Twitter，Instagram和Facebook应用程序。这是默认值。 uikit - iOS的默认效果。 cardStyle - 使用此道具覆盖或扩展堆栈中单个卡的默认样式。 transitionConfig - 函数返回与默认屏幕转换合并的对象（查看类型定义中的TransitionConfig ）。提供的函数将传递以下参数： transitionProps - 新屏幕的过渡转换。 prevTransitionProps - 旧屏幕的过渡转换。 isModal - 指定屏幕是否为模态。 onTransitionStart - 跳转动画即将开始时要调用的函数。 onTransitionEnd - 跳转动画完成后调用的函数。 navigationOptions 导航页面的属性和方法 title - 可用作的headerBackTitle的标题。此外，将用作tabBarLabel（如果嵌套在TabNavigator中）或drawerLabel（如果嵌套在DrawerNavigator中）的回退标题。 header - 返回一个React元素，用来作为标题。设置null会隐藏标题。 headerTitle - 可以传入字符串，React Element，React Component。默认是用上面的title作为标题。当使用Component时，它接受allowFontScaling，style和children作为属性。title会被放在children中。 headerTitleAllowFontScaling - 标题字体是否应该缩放以遵循系统设置。默认值为true。 headerBackImage - 接受React Element或者Component用来显示自定义的后退按钮中的图片。当使用组件时，它会得到(tintColor，title)参数。默认为react-navigation/views/assets/back-icon.png路径下的图片，这是区分平台的默认图标。 headerBackTitle - iOS上后退按钮使用的文字，传递null会禁用标签。默认为前一场景headerTitle。 headerTruncatedBackTitle - 当后退按钮使用的标题字符串headerBackTitle不适合屏幕时(比如说文字过长)，会默认显示Back。 headerRight - 接受React Element将会显示在标题的右侧。 headerLeft - 接受React Element或者React Component将会显示在标题的左侧。当传递一个组件的时候，会得到（onPress，title，titleStyle还有更多，请参考Header.js以获得完整的列表）。 headerStyle - 标题的样式 headerForceInset - 允许将forceInset对象传递给标题中，使用的内部SafeAreaView。 headerTitleStyle - 标题组件的样式 headerBackTitleStyle - 标题上后退按钮文字样式 headerTintColor - 标题组件的色调 headerPressColorAndroid - 材质纹波的颜色（仅限Android&gt; = 5.0） headerTransparent - 默认为false。如果为true标题将没有背景，除非你明确提供了headerStyle或headerBackground。 headerBackground - 将此与headerTransparent一起使用，以提供一个组件在标题的背景中呈现。例如，您可以将其用于模糊视图，以创建半透明标题。 gesturesEnabled - 是否可以使用手势来返回到上一页。在iOS上默认为true，在Android上为false。 gestureResponseDistance - 用于覆盖触摸从屏幕边缘开始识别手势的距离的对象。它具有以下属性： horizontal - number - 水平方向的距离。默认为25。 vertical - number - 垂直方向的距离。默认为135。 gestureDirection - 传递字符串用来覆盖关闭手势的方向。default为正常行为或inverted从右到左滑动。 Navigator Props 由StackNavigator（…）创建的导航器组件拥有下面的属性： screenProps - 将其他选项传递给子屏幕 createTabNavigator createTabNavigator已弃用。请改用createBottomTabNavigator和/或createMaterialTopTabNavigator。 createBottomTabNavigator 屏幕底部的简单标签栏，可让您在不同路由之间切换。路由是被懒惰初始化的 - 它们的屏幕组件直到第一次选中时才会初始化。这个方法在1.x中叫做TabNavigator，在2.x中统一命名为createBottomTabNavigator 1createBottomTabNavigator(RouteConfigs, BottomTabNavigatorConfig); RouteConfigs 属性请参考createStackNavigator。它的navigationOptions和createStackNavigator不一样，下面会有说明。 BottomTabNavigatorConfig initialRouteName - 第一次加载时初始选项卡路由的routeName。 order - 定义选项卡顺序的routeNames数组。 paths - 提供routeName到path的深度链接，它会覆盖RouteConfigs中设置的路径。 backBehavior - 后退按钮是否会导致标签切换到初始路由？如果是，则设置为initialRoute，否则none。默认为initialRoute。 tabBarComponent - Options，覆盖用作标签栏的组件。 tabBarOptions - 标签栏具有如下属性： activeTintColor - 活动选项卡的标签和图标颜色。(选中) activeBackgroundColor - 活动选项卡的背景颜色。(选中) inactiveTintColor - 非活动选项卡的标签和图标颜色。(未选中) inactiveBackgroundColor - 非活动选项卡的背景颜色。(未选中) showLabel - 是否显示标签，默认为true。 style - 标签栏的样式。 labelStyle - 标签栏文字的样式。 tabStyle - 选项卡的样式。 allowFontScaling - 标题字体是否应该缩放以遵循系统设置。默认值为true。 navigationOptions 标签栏的属性和方法 title - 通用标题可以用作headerTitle和tabBarLabel。 tabBarVisible - 显示或隐藏底部标签栏，默认为true，不隐藏。 tabBarIcon - React Element或给定{focused：boolean，tintColor：string}的函数返回一个React.Node，用来显示在标签栏中。 tabBarLabel - 接收字符串、React Element或者给定{focused：boolean，tintColor：string}的函数返回一个React.Node，用来显示在标签栏中。如果未定义，会使用title作为默认值。如果想要隐藏，可以参考上面的tabBarOptions.showLabel。 tabBarOnPress - 标签栏点击事件回调，接受一个对象，其中包含如下： 1234567891011121314tabBarOnPress: async (obj: any) =&gt; &#123; console.log(obj); try &#123; const userData = await AsyncStorage.getItem(&apos;USER_INFO&apos;); if (userData) &#123; obj.defaultHandler(); &#125; else &#123; obj.navigation.navigate(&apos;Login&apos;); &#125; &#125; catch (e) &#123; Toast.show(e.message, &apos;center&apos;, 1000); &#125; &#125; createMaterialTopTabNavigator 实现了类似react-native-scrollable-tab-view的左右滚动效果，但每个tab页是没有懒加载的，就是说，当使用这个生成导航的时候，每个页面都会初始化，对内存影响较大。这个导航是基于react-native-tab-view实现的，如果有需要可以研究。 1createMaterialTopTabNavigator(RouteConfigs, TabNavigatorConfig); RouteConfigs 属性请参考createStackNavigator。 TabNavigatorConfig initialRouteName - 第一次加载时初始选项卡路由的routeName。 order - 定义选项卡顺序的routeNames数组。 paths - 提供routeName到path的深度链接，它会覆盖RouteConfigs中设置的路径。 backBehavior - 后退按钮是否会导致标签切换到初始路由？如果是，则设置为initialRoute，否则none。默认为initialRoute。 swipeEnabled - 是否允许在标签之间滑动。 animationEnabled - 改变标签时是否使用动画。 configureTransition - 给定currentTransitionProps和nextTransitionProps返回一个描述选项卡之间动画的配置对象的函数。 initialLayout - 包含初始height和可选对象width，可以传递以防止react-native-tab-view出现一帧的延迟。 tabBarComponent - Options，覆盖用作标签栏的组件。 tabBarOptions - 标签栏具有如下属性： activeTintColor - 活动选项卡的标签和图标颜色。(选中) inactiveTintColor - 非活动选项卡的标签和图标颜色。(未选中) showIcon - 是否显示标签图标，默认为false。 showLabel - 是否显示标签，默认为true。 upperCaseLabel - 是否使标签大写，默认为true。 pressColor - 纹波的颜色（仅限Android&gt; = 5.0）。 pressOpacity - 按下标签的不透明度（仅iOS和Android &lt;5.0）。 scrollEnabled - 是否启用可滚动标签。 tabStyle - 选项卡的样式。 indicatorStyle - 选项卡指示符的样式（选项卡底部线的颜色）。 labelStyle - 标签栏文字的样式。 iconStyle - 选项卡图标的样式。 style - 标签栏的样式。 allowFontScaling - 标题字体是否应该缩放以遵循系统设置。默认值为true。 navigationOptions title - 通用标题可以用作headerTitle和tabBarLabel。 swipeEnabled - 如果未设置，则遵循TabNavigatorConfig选项swipeEnabled。启用或禁用标签之间的滑动操作为true或false。 tabBarIcon - React Element或给定{focused：boolean，tintColor：string}的函数返回一个React.Node，用来显示在标签栏中。 tabBarLabel - 接收字符串、React Element或者给定{focused：boolean，tintColor：string}的函数返回一个React.Node，用来显示在标签栏中。如果未定义，会使用title作为默认值。如果想要隐藏，可以参考上面的tabBarOptions.showLabel。 tabBarOnPress - 标签栏点击事件回调，接受一个对象，其中包含如下： 1234567891011121314tabBarOnPress: async (obj: any) =&gt; &#123; console.log(obj); try &#123; const userData = await AsyncStorage.getItem(&apos;USER_INFO&apos;); if (userData) &#123; obj.defaultHandler(); &#125; else &#123; obj.navigation.navigate(&apos;Login&apos;); &#125; &#125; catch (e) &#123; Toast.show(e.message, &apos;center&apos;, 1000); &#125; &#125; createDrawerNavigator 创建侧边栏导航，有一些坑，需要用过才知道。 1createDrawerNavigator(RouteConfigs, DrawerNavigatorConfig) RouteConfigs 属性请参考createStackNavigator。 DrawerNavigatorConfig drawerWidth - 抽屉的宽度或返回一个新的函数。 drawerPosition - 抽屉出现的方向left或right，默认left。 contentComponent - 用于呈现抽屉内容的组件，例如导航项。接收navigation抽屉的属性。默认为DrawerItems。有关更多信息，请参见下文。 contentOptions - 配置抽屉内容，请参见下文。 useNativeAnimations - 启用本地动画。默认是true。 drawerBackgroundColor - 设置抽屉的背景背景。默认是white。 initialRouteName - 第一次加载时初始选项卡路由的routeName。 order - 定义选项卡顺序的routeNames数组。 paths - 提供routeName到path的深度链接，它会覆盖RouteConfigs中设置的路径。 backBehavior - 后退按钮是否会导致标签切换到初始路由？如果是，则设置为initialRoute，否则none。默认为initialRoute。 contentComponent 提供自定义的抽屉效果抽屉的默认组件是可滚动的，只包含RouteConfig中路由的链接。您可以轻松地覆盖默认组件，以向抽屉中添加页眉，页脚或其他内容。默认情况下，抽屉可滚动并支持iPhone X安全区域。如果您自定义内容，请务必将内容包装在SafeAreaView中 DrawerItems的contentOptions items - 路由数组，可以修改或覆盖。 activeItemKey - 识别活动路线的key。 activeTintColor - 活动标签的标签和图标颜色。(选中) activeBackgroundColor - 活动标签的背景颜色。(选中) inactiveTintColor - 不活动标签的标签和图标颜色。(未选中) inactiveBackgroundColor - 不活动标签的背景颜色。(未选中) onItemPress(route) - 按下某个Item时调用的函数。 itemsContainerStyle - item内容的样式。 itemStyle - 单个Item样式，其中可以包含图标和标签。 labelStyle - 当标签是字符串时，会覆盖文字的样式。 activeLabelStyle - 当标签是字符串时，会覆盖选中的文字样式。 inactiveLabelStyle - 当标签是字符串时，会覆盖未选中的文字样式。 iconContainerStyle - 用来覆盖icon的样式 Screen Navigation Options title - 通用标题可以用作headerTitle和tabBarLabel。 drawerLabel - 可以传入字符串，React Element或给定{focused：boolean，tintColor：string}的函数返回一个React.Node，用来显示在抽屉边栏中。当不设置时，默认使用title。 drawerIcon - React Element或给定{focused：boolean，tintColor：string}的函数返回一个React.Node，用来显示在抽屉边栏中。 drawerLockMode - 指定抽屉的锁定模式。这也可以通过在顶级路由器上使用screenProps.drawerLockMode动态更新。 enum(&#39;unlocked&#39;, &#39;locked-closed&#39;, &#39;locked-open&#39;) createMaterialBottomTabNavigator这个方法在2.0正式版中被砍掉了，但官方文档没有更新，如果喜欢material风格，可以参考react-native-material-bottom-navigation常用属性方法 这部分会分为createStackNavigator和createDrawerNavigator两部分，因为它们属性不太一样。 createStackNavigator常用方法 在新版的react-navigation中实现了很多常用的api，比如说push，pop，popToTop等常用方法，在本文中会将属性和使用方法简单说明。 NavigationActions Navigate - 用来跳转到其他路由的方法 routeName - String - 必须 - 在RouteConfigs中注册过的路由名称 params - Object - 可选 - 传递的参数 action - Object - 可选 - （高级）如果屏幕是导航器，则在子路由器中运行的子操作。本文档中描述的任何一项操作都可以设置为子操作。 key - String - 可选 - 要导航到的路线的标识符。如果它已经存在，则返回到此路线。 1234567import &#123; NavigationActions &#125; from &apos;react-navigation&apos;;const navigateAction = NavigationActions.navigate(&#123; routeName: &apos;Profile&apos;, params: &#123;&#125;, action: NavigationActions.navigate(&#123; routeName: &apos;SubProfileRoute&apos; &#125;),&#125;);this.props.navigation.dispatch(navigateAction); Back - 用来返回到上一个路由或其他路由 Key - String | null - 如果设置，导航将从给定的键返回。如果为空，导航将返回到上一级。 12345import &#123; NavigationActions &#125; from &apos;react-navigation&apos;;const backAction = NavigationActions.back(&#123; key: &apos;Profile&apos;,&#125;);this.props.navigation.dispatch(backAction); SetParams 在调用SetParams时，路由器将产生一个新的状态，该状态已经改变了由key标识的特定路由参数 params - Object - 可选 - 新的参数被合并到现有的路径参数中。 key - String - 必须 - 获取新参数的路由键。 1234567import &#123; NavigationActions &#125; from &apos;react-navigation&apos;;const setParamsAction = NavigationActions.setParams(&#123; params: &#123; title: &apos;Hello&apos; &#125;, key: &apos;screen-123&apos;,&#125;);this.props.navigation.dispatch(setParamsAction); Reset - 重置路由 Reset操作将重置整个导航状态并将其替换为新的导航。 index - number - 必须 - 导航中routes活动路由的索引state。 actions - array - 必须 - 将替换导航数组。 key - string | null - 可选 - 如果设置，具有给定键的导航器将重置。如果为null，则根导航器将被重置。 123456import &#123; StackActions, NavigationActions &#125; from &apos;react-navigation&apos;;const resetAction = StackActions.reset(&#123; index: 0, actions: [NavigationActions.navigate(&#123; routeName: &apos;Profile&apos; &#125;)],&#125;);this.props.navigation.dispatch(resetAction); Replace - 用新的route替换当前的route Replace操作将给定key上的路线替换为另一条路线。 key - string - 必须 - 要替换​​路由的key。 newKey - string - 用于替换路由的key。如果未提供，则自动生成。 routeName - string - 用于替换路由的routeName。 params - object - 要传入替换路由的参数。 action - object - 可选的子操作。 Push - 入栈 Push操作会在堆栈顶部添加一条路径并向前导航。这与之前的不同之处在于，如果某个组件已经存在路由中，navigate则会弹出到堆栈中的较早版本。Push将始终添加在顶部，因此可以多次安装组件。 routeName - string - 要跳转路由的routeName。 params - object - 传递的参数，可以通过(this.props.navigation.state.params)找到。 action - 子操作。 pop(n) - 出栈 Pop操作将使您回到堆栈中的前一个屏幕。n参数允许您指定要多少个屏幕出栈。 n - number - 要出栈的屏幕数量。 PopToTop - 回到栈顶 PopToTop操作会将您带回堆栈中的第一个屏幕，解除所有其他屏幕。它的功能与StackActions.pop({n: currentIndex})类似。 总结react-navigation才开始用的时候感觉是复杂的，但用的多了，会感觉真的很不错。如果在文章中有什么不懂的问题，欢迎在评论区评论，也可以发私信，加QQ群397885169一起讨论哦]]></content>
  </entry>
</search>
